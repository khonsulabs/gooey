<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library that makes linear color calculations and conversion easy and accessible for anyone. It uses the type system to enforce correctness and to avoid mistakes, such as mixing incompatible color types."><meta name="keywords" content="rust, rustlang, rust-lang, palette"><title>gooey::core::palette - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../gooey/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate palette</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.1.0-dev.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all palette's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="palette" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a href="../../index.html">gooey</a>::<wbr><a href="../index.html">core</a>::<wbr><a class="mod" href="#">palette</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="https://docs.rs/palette/0.6.0/palette/src/palette/lib.rs.html#1-766" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A library that makes linear color calculations and conversion easy and
accessible for anyone. It uses the type system to enforce correctness and
to avoid mistakes, such as mixing incompatible color types.</p>
<h1 id="its-never-just-rgb" class="section-header"><a href="#its-never-just-rgb">It’s Never “Just RGB”</a></h1>
<p>Colors in images are often “gamma corrected”, or converted using some
non-linear transfer function into a format like sRGB before being stored or
displayed. This is done as a compression method and to prevent banding; it’s
also a bit of a legacy from the ages of the CRT monitors, where the output
from the electron gun was non-linear. The problem is that these formats are
<em>non-linear color spaces</em>, which means that many operations that you may
want to perform on colors (addition, subtraction, multiplication, linear
interpolation, etc.) will work unexpectedly when performed in such a
non-linear color space. Thus, the compression has to be reverted to restore
linearity and ensure that many operations on the colors behave as expected.</p>
<p>For example, this does not work:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="comment">// An alias for Rgb&lt;Srgb&gt;, which is what most pictures store.</span>
<span class="kw">use</span> <span class="ident">palette::Srgb</span>;

<span class="kw">let</span> <span class="ident">orangeish</span> <span class="op">=</span> <span class="ident">Srgb::new</span>(<span class="number">1.0</span>, <span class="number">0.6</span>, <span class="number">0.0</span>);
<span class="kw">let</span> <span class="ident">blueish</span> <span class="op">=</span> <span class="ident">Srgb::new</span>(<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">1.0</span>);
<span class="kw">let</span> <span class="ident">whatever_it_becomes</span> <span class="op">=</span> <span class="ident">orangeish</span> <span class="op">+</span> <span class="ident">blueish</span>; <span class="comment">// Does not compile</span></code></pre></div>
<p>Instead, they have to be made linear before adding:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// An alias for Rgb&lt;Srgb&gt;, which is what most pictures store.</span>
<span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">Pixel</span>, <span class="ident">Srgb</span>};

<span class="kw">let</span> <span class="ident">orangeish</span> <span class="op">=</span> <span class="ident">Srgb::new</span>(<span class="number">1.0</span>, <span class="number">0.6</span>, <span class="number">0.0</span>).<span class="ident">into_linear</span>();
<span class="kw">let</span> <span class="ident">blueish</span> <span class="op">=</span> <span class="ident">Srgb::new</span>(<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">1.0</span>).<span class="ident">into_linear</span>();
<span class="kw">let</span> <span class="ident">whatever_it_becomes</span> <span class="op">=</span> <span class="ident">orangeish</span> <span class="op">+</span> <span class="ident">blueish</span>;

<span class="comment">// Encode the result back into sRGB and create a byte array</span>
<span class="kw">let</span> <span class="ident">pixel</span>: [<span class="ident">u8</span>; <span class="number">3</span>] <span class="op">=</span> <span class="ident">Srgb::from_linear</span>(<span class="ident">whatever_it_becomes</span>)
    .<span class="ident">into_format</span>()
    .<span class="ident">into_raw</span>();</code></pre></div>
<p>See the <a href="rgb/index.html" title="rgb">rgb</a> module for a deeper dive into RGB and (non-)linearity.</p>
<h1 id="color-spaces" class="section-header"><a href="#color-spaces">Color Spaces</a></h1>
<p>“RGB” and other tristimulus based spaces like CIE Xyz are probably the most
widely known color spaces. These spaces are great when you want to perform
physically based math on color (like in a 2D or 3D rendering program) but
there are also color spaces that are not defined in terms of tristimulus
values.</p>
<p>You have probably used a color picker with a rainbow wheel and a brightness
slider. That may have been an HSV or an HSL color picker, where the color is
encoded as hue, saturation and brightness/lightness. Even though these
spaces are defined using 3 values, they <em>aren’t</em> based on tristimulus
values, since those three values don’t have a direct relation to human
vision (i.e. our L, M, and S cones).
Such color spaces are excellent when it comes to humans intuitively
selecting color values, and as such are the go-to choice when this
interaction is needed. They can then be converted into other color spaces
to perform modifications to them.</p>
<p>There’s also a group of color spaces that are designed to be perceptually
uniform, meaning that the perceptual change is equal to the numerical
change. An example of this is the CIE L*a*b* color space. These color
spaces are excellent when you want to “blend” between colors in a
<em>perceptually pleasing</em> manner rather than based on <em>physical light intensity</em>.</p>
<p>Selecting the proper color space can have a big impact on how the resulting
image looks (as illustrated by some of the programs in <code>examples</code>), and
Palette makes the conversion between them as easy as a call to <code>from_color</code>
or <code>into_color</code>.</p>
<p>This example takes an sRGB color, converts it to CIE L*C*h°, a color space
similar to the colloquial HSL/HSV color spaces, shifts its hue by 180° and
converts it back to RGB:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">FromColor</span>, <span class="ident">Hue</span>, <span class="ident">IntoColor</span>, <span class="ident">Lch</span>, <span class="ident">Srgb</span>};

<span class="kw">let</span> <span class="ident">lch_color</span>: <span class="ident">Lch</span> <span class="op">=</span> <span class="ident">Srgb::new</span>(<span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.1</span>).<span class="ident">into_color</span>();
<span class="kw">let</span> <span class="ident">new_color</span> <span class="op">=</span> <span class="ident">Srgb::from_color</span>(<span class="ident">lch_color</span>.<span class="ident">shift_hue</span>(<span class="number">180.0</span>));</code></pre></div>
<h1 id="transparency" class="section-header"><a href="#transparency">Transparency</a></h1>
<p>There are many cases where pixel transparency is important, but there are
also many cases where it becomes a dead weight, if it’s always stored
together with the color, but not used. Palette has therefore adopted a
structure where the transparency component (alpha) is attachable using the
<a href="struct.Alpha.html"><code>Alpha</code></a> type, instead of having copies of each color
space.</p>
<p>This approach comes with the extra benefit of allowing operations to
selectively affect the alpha component:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">LinSrgb</span>, <span class="ident">LinSrgba</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c1</span> <span class="op">=</span> <span class="ident">LinSrgba::new</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.8</span>);
<span class="kw">let</span> <span class="ident">c2</span> <span class="op">=</span> <span class="ident">LinSrgb::new</span>(<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);

<span class="ident">c1</span>.<span class="ident">color</span> <span class="op">=</span> <span class="ident">c1</span>.<span class="ident">color</span> <span class="op">*</span> <span class="ident">c2</span>; <span class="comment">//Leave the alpha as it is</span>
<span class="ident">c1</span>.<span class="ident">blue</span> <span class="op">+</span><span class="op">=</span> <span class="number">0.2</span>; <span class="comment">//The color components can easily be accessed</span>
<span class="ident">c1</span> <span class="op">=</span> <span class="ident">c1</span> <span class="op">*</span> <span class="number">0.5</span>; <span class="comment">//Scale both the color and the alpha</span></code></pre></div>
<h1 id="a-basic-workflow" class="section-header"><a href="#a-basic-workflow">A Basic Workflow</a></h1>
<p>The overall workflow can be divided into three steps, where the first and
last may be taken care of by other parts of the application:</p>
<div class="example-wrap"><pre class="language-text"><code>Decoding -&gt; Processing -&gt; Encoding</code></pre></div><h2 id="1-decoding" class="section-header"><a href="#1-decoding">1. Decoding</a></h2>
<p>Find out what the source format is and convert it to a linear color space.
There may be a specification, such as when working with SVG or CSS.</p>
<p>When working with RGB or gray scale (luma):</p>
<ul>
<li>
<p>If you are asking your user to enter an RGB value, you are in a gray zone
where it depends on the context. It’s usually safe to assume sRGB, but
sometimes it’s already linear.</p>
</li>
<li>
<p>If you are decoding an image, there may be some meta data that gives you
the necessary details. Otherwise it’s most commonly sRGB. Usually you
will end up with a slice or vector with RGB bytes, which can easily be
converted to Palette colors:</p>
</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">Srgb</span>, <span class="ident">Pixel</span>};

<span class="comment">// This works for any (even non-RGB) color type that can have the</span>
<span class="comment">// buffer element type as component.</span>
<span class="kw">let</span> <span class="ident">color_buffer</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">Srgb</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>] <span class="op">=</span> <span class="ident">Pixel::from_raw_slice_mut</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">image_buffer</span>);</code></pre></div>
<ul>
<li>If you are getting your colors from the GPU, in a game or other graphical
application, or if they are otherwise generated by the application, then
chances are that they are already linear. Still, make sure to check that
they are not being encoded somewhere.</li>
</ul>
<p>When working with other colors:</p>
<ul>
<li>
<p>For HSL, HSV, HWB: Check if they are based on any other color space than
sRGB, such as Adobe or Apple RGB.</p>
</li>
<li>
<p>For any of the CIE color spaces, check for a specification of white point
and light source. These are necessary for converting to RGB and other
colors, that depend on perception and “viewing devices”. Common defaults
are the D65 light source and the sRGB white point. The Palette defaults
should take you far.</p>
</li>
</ul>
<h2 id="2-processing" class="section-header"><a href="#2-processing">2. Processing</a></h2>
<p>When your color has been decoded into some Palette type, it’s ready for
processing. This includes things like blending, hue shifting, darkening and
conversion to other formats. Just make sure that your non-linear RGB is
made linear first (<code>my_srgb.into_linear()</code>), to make the operations
available.</p>
<p>Different color spaced have different capabilities, pros and cons. You may
have to experiment a bit (or look at the example programs) to find out what
gives the desired result.</p>
<h2 id="3-encoding" class="section-header"><a href="#3-encoding">3. Encoding</a></h2>
<p>When the desired processing is done, it’s time to encode the colors back
into some image format. The same rules applies as for the decoding, but the
process reversed.</p>
<h1 id="working-with-raw-data" class="section-header"><a href="#working-with-raw-data">Working with Raw Data</a></h1>
<p>Oftentimes, pixel data is stored in a raw buffer such as a <code>[u8; 3]</code>. The
<a href="trait.Pixel.html"><code>Pixel</code></a> trait allows for easy interoperation between
Palette colors and other crates or systems. <code>from_raw</code> can be used to
convert into a Palette color, <code>into_format</code> converts from  <code>Srgb&lt;u8&gt;</code> to
<code>Srgb&lt;f32&gt;</code>, and finally <code>into_raw</code> to convert from a Palette color back to
a <code>[u8;3]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">approx::assert_relative_eq</span>;
<span class="kw">use</span> <span class="ident">palette</span>::{<span class="ident">Srgb</span>, <span class="ident">Pixel</span>};

<span class="kw">let</span> <span class="ident">buffer</span> <span class="op">=</span> [<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>];
<span class="kw">let</span> <span class="ident">raw</span> <span class="op">=</span> <span class="ident">Srgb::from_raw</span>(<span class="kw-2">&amp;</span><span class="ident">buffer</span>);
<span class="macro">assert_eq!</span>(<span class="ident">raw</span>, <span class="kw-2">&amp;</span><span class="ident">Srgb</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="ident">::new</span>(<span class="number">255u8</span>, <span class="number">0</span>, <span class="number">255</span>));

<span class="kw">let</span> <span class="ident">raw_float</span>: <span class="ident">Srgb</span><span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">raw</span>.<span class="ident">into_format</span>();
<span class="macro">assert_relative_eq!</span>(<span class="ident">raw_float</span>, <span class="ident">Srgb::new</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));

<span class="kw">let</span> <span class="ident">raw</span>: [<span class="ident">u8</span>; <span class="number">3</span>] <span class="op">=</span> <span class="ident">Srgb::into_raw</span>(<span class="ident">raw_float</span>.<span class="ident">into_format</span>());
<span class="macro">assert_eq!</span>(<span class="ident">raw</span>, <span class="ident">buffer</span>);</code></pre></div>
</div></details><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="mod" href="blend/index.html" title="gooey::core::palette::blend mod">blend</a></div><div class="item-right docblock-short"><p>Color blending and blending equations.</p>
</div><div class="item-left module-item"><a class="mod" href="chromatic_adaptation/index.html" title="gooey::core::palette::chromatic_adaptation mod">chromatic_adaptation</a></div><div class="item-right docblock-short"><p>Convert colors from one reference white point to another</p>
</div><div class="item-left module-item"><a class="mod" href="convert/index.html" title="gooey::core::palette::convert mod">convert</a></div><div class="item-right docblock-short"><p>Traits for converting between color spaces.</p>
</div><div class="item-left module-item"><a class="mod" href="encoding/index.html" title="gooey::core::palette::encoding mod">encoding</a></div><div class="item-right docblock-short"><p>Various encoding traits, types and standards.</p>
</div><div class="item-left module-item"><a class="mod" href="float/index.html" title="gooey::core::palette::float mod">float</a></div><div class="item-right docblock-short"><p>Floating point trait</p>
</div><div class="item-left module-item"><a class="mod" href="gradient/index.html" title="gooey::core::palette::gradient mod">gradient</a></div><div class="item-right docblock-short"><p>Types for interpolation between multiple colors.</p>
</div><div class="item-left module-item"><a class="mod" href="luma/index.html" title="gooey::core::palette::luma mod">luma</a></div><div class="item-right docblock-short"><p>Luminance types.</p>
</div><div class="item-left module-item"><a class="mod" href="named/index.html" title="gooey::core::palette::named mod">named</a></div><div class="item-right docblock-short"><p>A collection of named color constants. Can be toggled with the <code>&quot;named&quot;</code> and
<code>&quot;named_from_str&quot;</code> Cargo features.</p>
</div><div class="item-left module-item"><a class="mod" href="rgb/index.html" title="gooey::core::palette::rgb mod">rgb</a></div><div class="item-right docblock-short"><p>RGB types, spaces and standards.</p>
</div><div class="item-left module-item"><a class="mod" href="white_point/index.html" title="gooey::core::palette::white_point mod">white_point</a></div><div class="item-right docblock-short"><p>Defines the tristimulus values of the CIE Illuminants.</p>
</div></div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.Alpha.html" title="gooey::core::palette::Alpha struct">Alpha</a></div><div class="item-right docblock-short"><p>An alpha component wrapper for colors.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Gradient.html" title="gooey::core::palette::Gradient struct">Gradient</a></div><div class="item-right docblock-short"><p>A linear interpolation between colors.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Hsl.html" title="gooey::core::palette::Hsl struct">Hsl</a></div><div class="item-right docblock-short"><p>HSL color space.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Hsluv.html" title="gooey::core::palette::Hsluv struct">Hsluv</a></div><div class="item-right docblock-short"><p>HSLuv color space.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Hsv.html" title="gooey::core::palette::Hsv struct">Hsv</a></div><div class="item-right docblock-short"><p>HSV color space.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Hwb.html" title="gooey::core::palette::Hwb struct">Hwb</a></div><div class="item-right docblock-short"><p>HWB color space.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Lab.html" title="gooey::core::palette::Lab struct">Lab</a></div><div class="item-right docblock-short"><p>The CIE L*a*b* (CIELAB) color space.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.LabHue.html" title="gooey::core::palette::LabHue struct">LabHue</a></div><div class="item-right docblock-short"><p>A hue type for the CIE L*a*b* family of color spaces.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Lch.html" title="gooey::core::palette::Lch struct">Lch</a></div><div class="item-right docblock-short"><p>CIE L*C*h°, a polar version of <a href="struct.Lab.html">CIE L*a*b*</a>.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Lchuv.html" title="gooey::core::palette::Lchuv struct">Lchuv</a></div><div class="item-right docblock-short"><p>CIE L*C*uv h°uv, a polar version of <a href="struct.Lab.html">CIE L*u*v*</a>.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Luv.html" title="gooey::core::palette::Luv struct">Luv</a></div><div class="item-right docblock-short"><p>The CIE L*u*v* (CIELUV) color space.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.LuvHue.html" title="gooey::core::palette::LuvHue struct">LuvHue</a></div><div class="item-right docblock-short"><p>A hue type for the CIE L*u*v* family of color spaces.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Oklab.html" title="gooey::core::palette::Oklab struct">Oklab</a></div><div class="item-right docblock-short"><p>The <a href="https://bottosson.github.io/posts/oklab/">Oklab color space</a>.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.OklabHue.html" title="gooey::core::palette::OklabHue struct">OklabHue</a></div><div class="item-right docblock-short"><p>A hue type for the Oklab color space.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Oklch.html" title="gooey::core::palette::Oklch struct">Oklch</a></div><div class="item-right docblock-short"><p>Oklch, a polar version of <a href="struct.Oklab.html">Oklab</a>.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Packed.html" title="gooey::core::palette::Packed struct">Packed</a></div><div class="item-right docblock-short"><p>RGBA color packed into a 32-bit unsigned integer. Defaults to ARGB
ordering for <code>Rgb</code> types and RGBA ordering for <code>Rgba</code> types.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.RgbHue.html" title="gooey::core::palette::RgbHue struct">RgbHue</a></div><div class="item-right docblock-short"><p>A hue type for the RGB family of color spaces.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Xyz.html" title="gooey::core::palette::Xyz struct">Xyz</a></div><div class="item-right docblock-short"><p>The CIE 1931 XYZ color space.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Yxy.html" title="gooey::core::palette::Yxy struct">Yxy</a></div><div class="item-right docblock-short"><p>The CIE 1931 Yxy (xyY)  color space.</p>
</div></div><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="trait" href="trait.Blend.html" title="gooey::core::palette::Blend trait">Blend</a></div><div class="item-right docblock-short"><p>A trait for colors that can be blended together.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.Clamp.html" title="gooey::core::palette::Clamp trait">Clamp</a></div><div class="item-right docblock-short"><p>A trait for clamping and checking if colors are within their ranges.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.ColorDifference.html" title="gooey::core::palette::ColorDifference trait">ColorDifference</a></div><div class="item-right docblock-short"><p>A trait for calculating the color difference between two colors.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.Component.html" title="gooey::core::palette::Component trait">Component</a></div><div class="item-right docblock-short"><p>Common trait for color components.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.ComponentWise.html" title="gooey::core::palette::ComponentWise trait">ComponentWise</a></div><div class="item-right docblock-short"><p>Perform a unary or binary operation on each component of a color.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.FloatComponent.html" title="gooey::core::palette::FloatComponent trait">FloatComponent</a></div><div class="item-right docblock-short"><p>Common trait for floating point color components.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.FromColor.html" title="gooey::core::palette::FromColor trait">FromColor</a></div><div class="item-right docblock-short"><p>A trait for converting one color from another, in a possibly lossy way.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.FromComponent.html" title="gooey::core::palette::FromComponent trait">FromComponent</a></div><div class="item-right docblock-short"><p>Converts from a color component type, while performing the appropriate
scaling, rounding and clamping.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.FromF64.html" title="gooey::core::palette::FromF64 trait">FromF64</a></div><div class="item-right docblock-short"><p>A trait for infallible conversion from <code>f64</code>. The conversion may be lossy.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.GetHue.html" title="gooey::core::palette::GetHue trait">GetHue</a></div><div class="item-right docblock-short"><p>A trait for colors where a hue may be calculated.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.Hue.html" title="gooey::core::palette::Hue trait">Hue</a></div><div class="item-right docblock-short"><p>A trait for colors where the hue can be manipulated without conversion.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.IntoColor.html" title="gooey::core::palette::IntoColor trait">IntoColor</a></div><div class="item-right docblock-short"><p>A trait for converting a color into another, in a possibly lossy way.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.IntoComponent.html" title="gooey::core::palette::IntoComponent trait">IntoComponent</a></div><div class="item-right docblock-short"><p>Converts into a color component type, while performing the appropriate
scaling, rounding and clamping.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.Mix.html" title="gooey::core::palette::Mix trait">Mix</a></div><div class="item-right docblock-short"><p>A trait for linear color interpolation.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.Pixel.html" title="gooey::core::palette::Pixel trait">Pixel</a></div><div class="item-right docblock-short"><p>Represents colors that can be serialized and deserialized from raw color
components.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.RelativeContrast.html" title="gooey::core::palette::RelativeContrast trait">RelativeContrast</a></div><div class="item-right docblock-short"><p>A trait for calculating relative contrast between two colors.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.RgbChannels.html" title="gooey::core::palette::RgbChannels trait">RgbChannels</a></div><div class="item-right docblock-short"><p>Splits and combines RGB(A) types with some channel ordering. Channels may be
ordered as <code>Abgr</code>, <code>Argb</code>, <code>Bgra</code>, or <code>Rgba</code>.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.Saturate.html" title="gooey::core::palette::Saturate trait">Saturate</a></div><div class="item-right docblock-short"><p>A trait for colors where the saturation (or chroma) can be manipulated
without conversion.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.Shade.html" title="gooey::core::palette::Shade trait">Shade</a></div><div class="item-right docblock-short"><p>The <code>Shade</code> trait allows a color to be lightened or darkened.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.WithAlpha.html" title="gooey::core::palette::WithAlpha trait">WithAlpha</a></div><div class="item-right docblock-short"><p>A trait for color types that can have or be given transparency (alpha channel).</p>
</div></div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="fn" href="fn.contrast_ratio.html" title="gooey::core::palette::contrast_ratio fn">contrast_ratio</a></div><div class="item-right docblock-short"><p>Calculate the ratio between two <code>luma</code> values.</p>
</div></div><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="type" href="type.GammaLuma.html" title="gooey::core::palette::GammaLuma type">GammaLuma</a></div><div class="item-right docblock-short"><p>Gamma 2.2 encoded luminance.</p>
</div><div class="item-left module-item"><a class="type" href="type.GammaLumaa.html" title="gooey::core::palette::GammaLumaa type">GammaLumaa</a></div><div class="item-right docblock-short"><p>Gamma 2.2 encoded luminance with an alpha component.</p>
</div><div class="item-left module-item"><a class="type" href="type.GammaSrgb.html" title="gooey::core::palette::GammaSrgb type">GammaSrgb</a></div><div class="item-right docblock-short"><p>Gamma 2.2 encoded sRGB.</p>
</div><div class="item-left module-item"><a class="type" href="type.GammaSrgba.html" title="gooey::core::palette::GammaSrgba type">GammaSrgba</a></div><div class="item-right docblock-short"><p>Gamma 2.2 encoded sRGB with an alpha component.</p>
</div><div class="item-left module-item"><a class="type" href="type.Hsla.html" title="gooey::core::palette::Hsla type">Hsla</a></div><div class="item-right docblock-short"><p>Linear HSL with an alpha component. See the <a href="struct.Alpha.html#Hsla"><code>Hsla</code> implementation in
<code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.Hsluva.html" title="gooey::core::palette::Hsluva type">Hsluva</a></div><div class="item-right docblock-short"><p>HSLuv with an alpha component. See the <a href="struct.Alpha.html#Hsluva"><code>Hsluva</code> implementation in
<code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.Hsva.html" title="gooey::core::palette::Hsva type">Hsva</a></div><div class="item-right docblock-short"><p>Linear HSV with an alpha component. See the <a href="struct.Alpha.html#Hsva"><code>Hsva</code> implementation in
<code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.Hwba.html" title="gooey::core::palette::Hwba type">Hwba</a></div><div class="item-right docblock-short"><p>Linear HWB with an alpha component. See the <a href="struct.Alpha.html#Hwba"><code>Hwba</code> implementation in
<code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.Laba.html" title="gooey::core::palette::Laba type">Laba</a></div><div class="item-right docblock-short"><p>CIE L*a*b* (CIELAB) with an alpha component. See the <a href="struct.Alpha.html#Laba"><code>Laba</code>
implementation in <code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.Lcha.html" title="gooey::core::palette::Lcha type">Lcha</a></div><div class="item-right docblock-short"><p>CIE L*C*h° with an alpha component. See the <a href="struct.Alpha.html#Lcha"><code>Lcha</code> implementation in
<code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.Lchuva.html" title="gooey::core::palette::Lchuva type">Lchuva</a></div><div class="item-right docblock-short"><p>CIE L*C*uv h°uv with an alpha component. See the <a href="struct.Alpha.html#Lchuva"><code>Lchuva</code> implementation in
<code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.LinLuma.html" title="gooey::core::palette::LinLuma type">LinLuma</a></div><div class="item-right docblock-short"><p>Linear luminance.</p>
</div><div class="item-left module-item"><a class="type" href="type.LinLumaa.html" title="gooey::core::palette::LinLumaa type">LinLumaa</a></div><div class="item-right docblock-short"><p>Linear luminance with an alpha component.</p>
</div><div class="item-left module-item"><a class="type" href="type.LinSrgb.html" title="gooey::core::palette::LinSrgb type">LinSrgb</a></div><div class="item-right docblock-short"><p>Linear sRGB.</p>
</div><div class="item-left module-item"><a class="type" href="type.LinSrgba.html" title="gooey::core::palette::LinSrgba type">LinSrgba</a></div><div class="item-right docblock-short"><p>Linear sRGB with an alpha component.</p>
</div><div class="item-left module-item"><a class="type" href="type.Luva.html" title="gooey::core::palette::Luva type">Luva</a></div><div class="item-right docblock-short"><p>CIE L*u*v* (CIELUV) with an alpha component. See the <a href="struct.Alpha.html#Luva"><code>Luva</code>
implementation in <code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.Mat3.html" title="gooey::core::palette::Mat3 type">Mat3</a></div><div class="item-right docblock-short"><p>A 9 element array representing a 3x3 matrix.</p>
</div><div class="item-left module-item"><a class="type" href="type.Oklaba.html" title="gooey::core::palette::Oklaba type">Oklaba</a></div><div class="item-right docblock-short"><p>Oklab with an alpha component. See the <a href="struct.Alpha.html#Oklaba"><code>Oklaba</code> implementation in
<code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.Oklcha.html" title="gooey::core::palette::Oklcha type">Oklcha</a></div><div class="item-right docblock-short"><p>Oklch with an alpha component. See the <a href="struct.Alpha.html#Oklcha"><code>Oklcha</code> implementation in
<code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.Srgb.html" title="gooey::core::palette::Srgb type">Srgb</a></div><div class="item-right docblock-short"><p>Non-linear sRGB.</p>
</div><div class="item-left module-item"><a class="type" href="type.SrgbLuma.html" title="gooey::core::palette::SrgbLuma type">SrgbLuma</a></div><div class="item-right docblock-short"><p>sRGB encoded luminance.</p>
</div><div class="item-left module-item"><a class="type" href="type.SrgbLumaa.html" title="gooey::core::palette::SrgbLumaa type">SrgbLumaa</a></div><div class="item-right docblock-short"><p>sRGB encoded luminance with an alpha component.</p>
</div><div class="item-left module-item"><a class="type" href="type.Srgba.html" title="gooey::core::palette::Srgba type">Srgba</a></div><div class="item-right docblock-short"><p>Non-linear sRGB with an alpha component.</p>
</div><div class="item-left module-item"><a class="type" href="type.Xyza.html" title="gooey::core::palette::Xyza type">Xyza</a></div><div class="item-right docblock-short"><p>CIE 1931 XYZ with an alpha component. See the <a href="struct.Alpha.html#Xyza"><code>Xyza</code> implementation in
<code>Alpha</code></a>.</p>
</div><div class="item-left module-item"><a class="type" href="type.Yxya.html" title="gooey::core::palette::Yxya type">Yxya</a></div><div class="item-right docblock-short"><p>CIE 1931 Yxy (xyY) with an alpha component. See the <a href="struct.Alpha.html#Yxya"><code>Yxya</code> implementation
in <code>Alpha</code></a>.</p>
</div></div><h2 id="derives" class="section-header"><a href="#derives">Derive Macros</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="derive" href="derive.Pixel.html" title="gooey::core::palette::Pixel derive">Pixel</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="derive" href="derive.WithAlpha.html" title="gooey::core::palette::WithAlpha derive">WithAlpha</a></div><div class="item-right docblock-short"></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="gooey" data-search-index-js="../../../search-index.js" data-search-js="../../../search.js"></div>
    <script src="../../../main.js"></script>
</body></html>